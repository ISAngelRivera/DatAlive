{
  "name": "DataLive - Ingestion Workflow",
  "nodes": [
    {
      "parameters": {
        "path": "datalive/ingest",
        "httpMethod": "POST",
        "responseMode": "lastNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "webhook-ingest",
      "name": "Document Ingestion Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "datalive-ingest"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate input data\nconst body = $input.item.json.body;\nlet data;\n\ntry {\n  data = typeof body === 'string' ? JSON.parse(body) : body;\n} catch (error) {\n  throw new Error('Invalid JSON in request body');\n}\n\n// Validate required fields\nif (!data.source_type || !data.source) {\n  throw new Error('Missing required fields: source_type and source');\n}\n\n// Validate source type\nconst validTypes = ['txt', 'pdf', 'docx', 'md', 'csv', 'json'];\nif (!validTypes.includes(data.source_type)) {\n  throw new Error(`Invalid source_type. Must be one of: ${validTypes.join(', ')}`);\n}\n\n// Add metadata\nconst metadata = {\n  ...data.metadata,\n  ingested_at: new Date().toISOString(),\n  source_type: data.source_type,\n  filename: data.filename || 'document.txt'\n};\n\nreturn {\n  content: data.source,\n  source_type: data.source_type,\n  metadata: metadata\n};"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "id": "text-splitter",
      "name": "Split Text into Chunks",
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "model": "nomic-embed-text:v1.5",
        "options": {}
      },
      "id": "embeddings-ollama",
      "name": "Generate Embeddings",
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [850, 300],
      "credentials": {
        "ollamaApi": {
          "id": "1",
          "name": "Ollama"
        }
      }
    },
    {
      "parameters": {
        "qdrantCollection": {
          "mode": "list",
          "collection": "datalive_documents"
        },
        "options": {}
      },
      "id": "qdrant-insert",
      "name": "Store in Qdrant",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreQdrant",
      "typeVersion": 1,
      "position": [1050, 300],
      "credentials": {
        "qdrantApi": {
          "id": "2",
          "name": "Qdrant"
        }
      }
    },
    {
      "parameters": {
        "operation": "insert",
        "tableId": "documents",
        "dataMode": "defineBelow",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldName": "source_type",
              "fieldValue": "={{ $('validate-input').item.json.source_type }}"
            },
            {
              "fieldName": "content",
              "fieldValue": "={{ $('validate-input').item.json.content }}"
            },
            {
              "fieldName": "metadata",
              "fieldValue": "={{ JSON.stringify($('validate-input').item.json.metadata) }}"
            },
            {
              "fieldName": "chunk_count",
              "fieldValue": "={{ $('text-splitter').context.itemsLength }}"
            },
            {
              "fieldName": "created_at",
              "fieldValue": "={{ new Date().toISOString() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "postgres-metadata",
      "name": "Store Metadata in PostgreSQL",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1050, 450],
      "credentials": {
        "postgres": {
          "id": "3",
          "name": "PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract entities and prepare for Neo4j\nconst content = $('validate-input').item.json.content;\nconst metadata = $('validate-input').item.json.metadata;\n\n// Simple entity extraction (in production, use LLM)\nconst emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g;\nconst urlRegex = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/g;\n\nconst emails = content.match(emailRegex) || [];\nconst urls = content.match(urlRegex) || [];\n\n// Create nodes and relationships\nconst documentNode = {\n  id: metadata.filename || 'doc_' + Date.now(),\n  label: 'Document',\n  properties: {\n    title: metadata.title || metadata.filename,\n    source_type: metadata.source_type,\n    created_at: metadata.ingested_at\n  }\n};\n\nconst entities = [];\nconst relationships = [];\n\n// Add email entities\nemails.forEach(email => {\n  entities.push({\n    id: email,\n    label: 'Email',\n    properties: { address: email }\n  });\n  relationships.push({\n    from: documentNode.id,\n    to: email,\n    type: 'MENTIONS_EMAIL'\n  });\n});\n\n// Add URL entities\nurls.forEach(url => {\n  entities.push({\n    id: url,\n    label: 'URL',\n    properties: { url: url }\n  });\n  relationships.push({\n    from: documentNode.id,\n    to: url,\n    type: 'REFERENCES_URL'\n  });\n});\n\nreturn {\n  document: documentNode,\n  entities: entities,\n  relationships: relationships\n};"
      },
      "id": "extract-entities",
      "name": "Extract Entities",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 450]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-response",
        "responseMode": "onReceived",
        "responseData": "={{JSON.stringify({status: 'success', message: 'Document ingested successfully', chunks: $('text-splitter').context.itemsLength, document_id: $('postgres-metadata').item.json.id})}}"
      },
      "id": "response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1250, 300]
    }
  ],
  "connections": {
    "Document Ingestion Webhook": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Split Text into Chunks",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Entities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Text into Chunks": {
      "main": [
        [
          {
            "node": "Generate Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embeddings": {
      "main": [
        [
          {
            "node": "Store in Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Qdrant": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Entities": {
      "main": [
        [
          {
            "node": "Store Metadata in PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Metadata in PostgreSQL": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [
    {
      "name": "DataLive",
      "createdAt": "2024-01-04T12:00:00.000Z"
    }
  ],
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "datalive-instance"
  }
}