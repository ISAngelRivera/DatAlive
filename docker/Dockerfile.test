# Dockerfile.test - Container especializado para testing de DataLive
FROM ubuntu:22.04

# Evitar prompts interactivos
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Europe/Madrid

# Instalar dependencias necesarias para testing
RUN apt-get update && apt-get install -y \
    # Herramientas b√°sicas
    curl \
    wget \
    jq \
    netcat \
    dnsutils \
    iputils-ping \
    telnet \
    vim \
    less \
    # Cliente PostgreSQL
    postgresql-client \
    # Cliente Redis
    redis-tools \
    # Python para scripts avanzados
    python3 \
    python3-pip \
    python3-requests \
    # Git para versionado
    git \
    # Herramientas de red
    net-tools \
    tcpdump \
    # Monitoreo
    htop \
    iotop \
    # Utilidades
    unzip \
    ca-certificates \
    gnupg \
    lsb-release \
    && rm -rf /var/lib/apt/lists/*

# Instalar Docker CLI para poder ejecutar docker commands
RUN curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - && \
    echo "deb [arch=$(dpkg --print-architecture)] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list && \
    apt-get update && \
    apt-get install -y docker-ce-cli && \
    rm -rf /var/lib/apt/lists/*

# Instalar MinIO client
RUN wget https://dl.min.io/client/mc/release/linux-arm64/mc -O /usr/local/bin/mc && \
    chmod +x /usr/local/bin/mc

# Instalar Python packages para testing avanzado
RUN pip3 install --no-cache-dir \
    pytest \
    requests \
    psycopg2-binary \
    redis \
    minio \
    qdrant-client \
    colorama \
    tabulate \
    python-dotenv

# Crear usuario para testing
RUN useradd -m -s /bin/bash tester && \
    usermod -aG docker tester 2>/dev/null || true

# Crear estructura de directorios
RUN mkdir -p /tests/scripts /tests/logs /tests/reports /tests/data && \
    chown -R tester:tester /tests

# Copiar scripts de testing al contenedor
WORKDIR /tests

# Script de entrada principal
COPY <<'EOF' /tests/entrypoint.sh
#!/bin/bash
echo "üß™ DataLive Test Container Ready"
echo "================================"
echo "Available test commands:"
echo "  - test-health     : Run system health checks"
echo "  - test-rag        : Test RAG functionality"
echo "  - test-all        : Run all tests"
echo "  - test-continuous : Run tests every 5 minutes"
echo ""
echo "Or run bash for interactive testing"

# Si se pasa un comando, ejecutarlo
if [ $# -gt 0 ]; then
    exec "$@"
else
    exec /bin/bash
fi
EOF

# Script de health check mejorado
COPY <<'EOF' /tests/scripts/test-health.py
#!/usr/bin/env python3
import os
import sys
import time
import json
import requests
import psycopg2
import redis
from datetime import datetime
from colorama import Fore, Style, init
from tabulate import tabulate

init(autoreset=True)

class HealthChecker:
    def __init__(self):
        self.results = []
        self.load_env()
        
    def load_env(self):
        """Load environment variables"""
        self.postgres_host = os.getenv('POSTGRES_HOST', 'postgres')
        self.postgres_user = os.getenv('POSTGRES_USER', 'admin')
        self.postgres_pass = os.getenv('POSTGRES_PASSWORD', 'adminpassword')
        self.postgres_db = os.getenv('POSTGRES_DB', 'datalive_db')
        self.redis_host = os.getenv('REDIS_HOST', 'redis')
        self.redis_pass = os.getenv('REDIS_PASSWORD', 'adminpassword')
        
    def test_service(self, name, test_func, critical=True):
        """Test a service and record results"""
        print(f"\n{Fore.CYAN}Testing {name}...{Style.RESET_ALL}")
        try:
            start = time.time()
            result = test_func()
            elapsed = (time.time() - start) * 1000
            self.results.append({
                'service': name,
                'status': 'PASS',
                'message': result,
                'time_ms': f"{elapsed:.0f}",
                'critical': critical
            })
            print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} {result}")
            return True
        except Exception as e:
            self.results.append({
                'service': name,
                'status': 'FAIL',
                'message': str(e),
                'time_ms': 'N/A',
                'critical': critical
            })
            print(f"  {Fore.RED}‚úó{Style.RESET_ALL} {str(e)}")
            return False
    
    def test_postgres(self):
        """Test PostgreSQL connection and schemas"""
        conn = psycopg2.connect(
            host=self.postgres_host,
            user=self.postgres_user,
            password=self.postgres_pass,
            database=self.postgres_db,
            connect_timeout=5
        )
        cur = conn.cursor()
        
        # Check schemas
        cur.execute("""
            SELECT COUNT(*) FROM information_schema.schemata 
            WHERE schema_name IN ('rag', 'kag', 'cag', 'monitoring')
        """)
        schema_count = cur.fetchone()[0]
        
        # Check tables
        cur.execute("""
            SELECT COUNT(*) FROM information_schema.tables 
            WHERE table_schema IN ('rag', 'kag', 'cag', 'monitoring')
        """)
        table_count = cur.fetchone()[0]
        
        conn.close()
        return f"Connected. Schemas: {schema_count}/4, Tables: {table_count}"
    
    def test_redis(self):
        """Test Redis connection"""
        r = redis.Redis(
            host=self.redis_host,
            password=self.redis_pass,
            decode_responses=True,
            socket_connect_timeout=5
        )
        r.ping()
        
        # Test set/get
        test_key = f"health_check_{int(time.time())}"
        r.setex(test_key, 10, "test_value")
        value = r.get(test_key)
        r.delete(test_key)
        
        return f"Connected. Set/Get OK"
    
    def test_http_service(self, name, url, expected_status=200):
        """Generic HTTP service test"""
        def _test():
            resp = requests.get(url, timeout=5)
            if resp.status_code != expected_status:
                raise Exception(f"Status {resp.status_code}")
            
            # Try to get version or other info
            try:
                data = resp.json()
                if 'version' in data:
                    return f"Connected. Version: {data['version']}"
                elif 'status' in data:
                    return f"Connected. Status: {data['status']}"
            except:
                pass
                
            return f"Connected. Status: {resp.status_code}"
        
        return self.test_service(name, _test)
    
    def test_ollama(self):
        """Test Ollama and check models"""
        resp = requests.get('http://ollama:11434/api/tags', timeout=5)
        models = resp.json().get('models', [])
        model_names = [m['name'] for m in models]
        return f"Connected. Models: {', '.join(model_names) if model_names else 'None'}"
    
    def test_qdrant(self):
        """Test Qdrant and check collections"""
        resp = requests.get('http://qdrant:6333/collections', timeout=5)
        collections = resp.json().get('result', {}).get('collections', [])
        return f"Connected. Collections: {len(collections)}"
    
    def run_all_tests(self):
        """Run all health checks"""
        print(f"\n{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.MAGENTA}DataLive Health Check - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}")
        print(f"{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
        
        # Core services
        self.test_service("PostgreSQL", self.test_postgres)
        self.test_service("Redis", self.test_redis)
        self.test_http_service("N8N", "http://n8n:5678/healthz")
        self.test_service("Ollama", self.test_ollama)
        self.test_service("Qdrant", self.test_qdrant)
        self.test_http_service("MinIO", "http://minio:9000/minio/health/ready")
        
        # Monitoring services
        self.test_http_service("Grafana", "http://grafana:3000/api/health", critical=False)
        self.test_http_service("Prometheus", "http://prometheus:9090/-/healthy", critical=False)
        self.test_http_service("Loki", "http://loki:3100/ready", critical=False)
        
        # Print summary
        self.print_summary()
        
    def print_summary(self):
        """Print test summary"""
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}Test Summary{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}\n")
        
        # Create table
        headers = ['Service', 'Status', 'Response', 'Time (ms)']
        rows = []
        
        for result in self.results:
            status_icon = f"{Fore.GREEN}‚úì PASS{Style.RESET_ALL}" if result['status'] == 'PASS' else f"{Fore.RED}‚úó FAIL{Style.RESET_ALL}"
            rows.append([
                result['service'],
                status_icon,
                result['message'][:50] + '...' if len(result['message']) > 50 else result['message'],
                result['time_ms']
            ])
        
        print(tabulate(rows, headers=headers, tablefmt='grid'))
        
        # Statistics
        total = len(self.results)
        passed = sum(1 for r in self.results if r['status'] == 'PASS')
        critical_failed = sum(1 for r in self.results if r['status'] == 'FAIL' and r['critical'])
        
        print(f"\n{Fore.CYAN}Statistics:{Style.RESET_ALL}")
        print(f"  Total Tests: {total}")
        print(f"  Passed: {Fore.GREEN}{passed}{Style.RESET_ALL}")
        print(f"  Failed: {Fore.RED}{total - passed}{Style.RESET_ALL}")
        
        if critical_failed > 0:
            print(f"\n{Fore.RED}‚ö†Ô∏è  SYSTEM UNHEALTHY - {critical_failed} critical services failed{Style.RESET_ALL}")
            sys.exit(1)
        elif passed < total:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  SYSTEM DEGRADED - Some non-critical services failed{Style.RESET_ALL}")
        else:
            print(f"\n{Fore.GREEN}‚úÖ SYSTEM HEALTHY - All services operational{Style.RESET_ALL}")

if __name__ == "__main__":
    checker = HealthChecker()
    checker.run_all_tests()
EOF

# Script de RAG testing
COPY <<'EOF' /tests/scripts/test-rag.py
#!/usr/bin/env python3
import os
import sys
import json
import time
import requests
import numpy as np
from datetime import datetime
from colorama import Fore, Style, init
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams, PointStruct

init(autoreset=True)

class RAGTester:
    def __init__(self):
        self.ollama_url = "http://ollama:11434"
        self.qdrant_client = QdrantClient(host="qdrant", port=6333)
        self.test_collection = "test_rag_collection"
        
    def print_header(self, text):
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{text}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        
    def test_embedding_generation(self):
        """Test embedding generation with Ollama"""
        self.print_header("1. Testing Embedding Generation")
        
        test_texts = [
            "DataLive es un sistema RAG h√≠brido on-premise",
            "Procesa documentos empresariales de forma segura",
            "Utiliza inteligencia artificial local"
        ]
        
        embeddings = []
        for text in test_texts:
            print(f"\n  Testing: '{text[:50]}...'")
            
            try:
                response = requests.post(
                    f"{self.ollama_url}/api/embeddings",
                    json={
                        "model": "phi4-mini:latest",
                        "prompt": text
                    }
                )
                
                if response.status_code == 200:
                    embedding = response.json()['embedding']
                    embeddings.append(embedding)
                    print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} Generated embedding with {len(embedding)} dimensions")
                else:
                    print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Failed: {response.status_code}")
                    
            except Exception as e:
                print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Error: {str(e)}")
                
        return embeddings
        
    def test_vector_storage(self, embeddings):
        """Test vector storage in Qdrant"""
        self.print_header("2. Testing Vector Storage")
        
        # Create collection
        try:
            self.qdrant_client.recreate_collection(
                collection_name=self.test_collection,
                vectors_config=VectorParams(
                    size=len(embeddings[0]),
                    distance=Distance.COSINE
                )
            )
            print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} Created collection '{self.test_collection}'")
        except Exception as e:
            print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Failed to create collection: {e}")
            return False
            
        # Insert vectors
        points = []
        for i, embedding in enumerate(embeddings):
            points.append(PointStruct(
                id=i,
                vector=embedding,
                payload={
                    "text": f"Document {i}",
                    "timestamp": datetime.now().isoformat()
                }
            ))
            
        try:
            self.qdrant_client.upsert(
                collection_name=self.test_collection,
                points=points
            )
            print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} Inserted {len(points)} vectors")
            return True
        except Exception as e:
            print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Failed to insert vectors: {e}")
            return False
            
    def test_vector_search(self):
        """Test vector similarity search"""
        self.print_header("3. Testing Vector Search")
        
        search_query = "sistema de inteligencia artificial"
        print(f"\n  Search query: '{search_query}'")
        
        # Generate embedding for search
        try:
            response = requests.post(
                f"{self.ollama_url}/api/embeddings",
                json={
                    "model": "phi4-mini:latest",
                    "prompt": search_query
                }
            )
            
            if response.status_code == 200:
                query_embedding = response.json()['embedding']
                print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} Generated query embedding")
                
                # Search
                results = self.qdrant_client.search(
                    collection_name=self.test_collection,
                    query_vector=query_embedding,
                    limit=3
                )
                
                print(f"\n  {Fore.CYAN}Search Results:{Style.RESET_ALL}")
                for i, result in enumerate(results):
                    print(f"    {i+1}. Score: {result.score:.4f}, ID: {result.id}")
                    
                return True
            else:
                print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Failed to generate query embedding")
                return False
                
        except Exception as e:
            print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Search error: {e}")
            return False
            
    def test_llm_generation(self):
        """Test LLM text generation"""
        self.print_header("4. Testing LLM Generation")
        
        prompts = [
            "¬øQu√© es DataLive en una frase?",
            "Lista 3 caracter√≠sticas de un sistema RAG:",
            "Explica brevemente qu√© es un embedding:"
        ]
        
        for prompt in prompts:
            print(f"\n  Prompt: '{prompt}'")
            
            try:
                response = requests.post(
                    f"{self.ollama_url}/api/generate",
                    json={
                        "model": "phi4-mini:latest",
                        "prompt": prompt,
                        "stream": False,
                        "options": {
                            "temperature": 0.7,
                            "max_tokens": 100
                        }
                    },
                    timeout=30
                )
                
                if response.status_code == 200:
                    generated = response.json()['response']
                    print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} Response: {generated[:100]}...")
                else:
                    print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Failed: {response.status_code}")
                    
            except Exception as e:
                print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Error: {str(e)}")
                
    def test_full_rag_pipeline(self):
        """Test complete RAG pipeline"""
        self.print_header("5. Testing Full RAG Pipeline")
        
        # Simulate document
        document = """
        DataLive es una plataforma de inteligencia artificial empresarial
        que permite procesar documentos de forma segura y privada.
        Utiliza modelos de lenguaje locales y no env√≠a datos a la nube.
        """
        
        query = "¬øEs DataLive seguro para datos empresariales?"
        
        print(f"  Document: {document[:100]}...")
        print(f"  Query: {query}")
        
        try:
            # Generate embeddings
            doc_resp = requests.post(f"{self.ollama_url}/api/embeddings", 
                json={"model": "phi4-mini:latest", "prompt": document})
            query_resp = requests.post(f"{self.ollama_url}/api/embeddings",
                json={"model": "phi4-mini:latest", "prompt": query})
                
            if doc_resp.status_code == 200 and query_resp.status_code == 200:
                # Calculate similarity
                doc_emb = np.array(doc_resp.json()['embedding'])
                query_emb = np.array(query_resp.json()['embedding'])
                
                similarity = np.dot(doc_emb, query_emb) / (np.linalg.norm(doc_emb) * np.linalg.norm(query_emb))
                print(f"\n  {Fore.GREEN}‚úì{Style.RESET_ALL} Similarity score: {similarity:.4f}")
                
                # Generate answer with context
                prompt = f"""Contexto: {document}
                
Pregunta: {query}

Respuesta basada en el contexto:"""
                
                gen_resp = requests.post(
                    f"{self.ollama_url}/api/generate",
                    json={
                        "model": "phi4-mini:latest",
                        "prompt": prompt,
                        "stream": False
                    },
                    timeout=30
                )
                
                if gen_resp.status_code == 200:
                    answer = gen_resp.json()['response']
                    print(f"  {Fore.GREEN}‚úì{Style.RESET_ALL} Generated answer: {answer[:200]}...")
                    
        except Exception as e:
            print(f"  {Fore.RED}‚úó{Style.RESET_ALL} Pipeline error: {e}")
            
    def cleanup(self):
        """Clean up test data"""
        try:
            self.qdrant_client.delete_collection(self.test_collection)
            print(f"\n{Fore.YELLOW}Cleaned up test collection{Style.RESET_ALL}")
        except:
            pass
            
    def run_all_tests(self):
        """Run all RAG tests"""
        print(f"\n{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.MAGENTA}DataLive RAG Functionality Test{Style.RESET_ALL}")
        print(f"{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
        
        # Run tests
        embeddings = self.test_embedding_generation()
        
        if embeddings:
            self.test_vector_storage(embeddings)
            self.test_vector_search()
            
        self.test_llm_generation()
        self.test_full_rag_pipeline()
        
        # Cleanup
        self.cleanup()
        
        print(f"\n{Fore.GREEN}‚úÖ RAG testing completed{Style.RESET_ALL}")

if __name__ == "__main__":
    tester = RAGTester()
    tester.run_all_tests()
EOF

# Hacer scripts ejecutables
RUN chmod +x /tests/entrypoint.sh /tests/scripts/*.py

# Cambiar a usuario tester
USER tester
WORKDIR /tests

# Entrypoint
ENTRYPOINT ["/tests/entrypoint.sh"]
CMD ["bash"]