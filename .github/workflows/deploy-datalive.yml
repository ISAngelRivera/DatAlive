name: Deploy DataLive System

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      action:
        description: 'Deployment action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - update
          - restart
          - backup
          - destroy

  push:
    branches:
      - main
    paths:
      - 'docker/**'
      - 'workflows/**'
      - 'scripts/**'
      - '.env.template'

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  TZ: Europe/Madrid

jobs:
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: self-hosted
    outputs:
      deploy-id: ${{ steps.deploy-id.outputs.id }}
      should-deploy: ${{ steps.check-changes.outputs.should-deploy }}
    steps:
      - name: Generate Deployment ID
        id: deploy-id
        run: echo "id=datalive-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

      - name: Check Runner Environment
        run: |
          echo "üîç Checking environment..."
          echo "Runner: $(hostname)"
          echo "User: $(whoami)"
          docker --version || (echo "‚ùå Docker not found" && exit 1)
          docker compose version || docker-compose --version || (echo "‚ùå Docker Compose not found" && exit 1)
          echo "Disk space:"
          df -h | grep -E "^/dev/"
          echo "Memory:"
          free -h || vm_stat | head -10
          
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check What Changed
        id: check-changes
        if: github.event_name == 'push'
        run: |
          echo "Files changed in this push:"
          git diff --name-only HEAD~1 HEAD
          
          # Check if deployment is needed
          if git diff --name-only HEAD~1 HEAD | grep -E "(docker/|workflows/|scripts/|\.env\.template)"; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment needed due to infrastructure changes"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No deployment needed (no infrastructure changes)"
          fi

      - name: Validate Repository Structure
        run: |
          echo "üìÅ Validating project structure..."
          required_files=(
            ".env.template"
            "docker/docker-compose.yml"
            "scripts/setup-datalive.sh"
            "scripts/init-ollama-models.sh"
            "scripts/init-minio-buckets.sh"
            "scripts/init-n8n-setup.sh"
            "scripts/init-qdrant-collections.sh"
            "scripts/wait-for-healthy.sh"
            "scripts/sync-n8n-workflows.sh"
          )
          
          missing_files=()
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              missing_files+=("$file")
            fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
            echo "‚ùå Missing required files:"
            printf '%s\n' "${missing_files[@]}"
            exit 1
          fi
          
          echo "‚úÖ All required files present"

  setup-environment:
    name: Setup Environment
    runs-on: self-hosted
    needs: pre-deployment
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'push' && needs.pre-deployment.outputs.should-deploy == 'true')
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Directory Structure
        run: |
          echo "üìÅ Creating directory structure..."
          directories=(
            "secrets"
            "logs"
            "backups/postgres"
            "backups/qdrant"
            "backups/n8n"
            "config/n8n"
            "config/ollama"
            "config/minio"
            "config/qdrant"
            "config/prometheus"
            "config/grafana/provisioning/datasources"
            "config/grafana/provisioning/dashboards"
            "config/grafana/dashboards"
            "config/loki"
            "config/promtail"
          )
          
          for dir in "${directories[@]}"; do
            mkdir -p "$dir"
            echo "   ‚úì Created $dir"
          done

      - name: Generate .env from Template
        run: |
          echo "üîß Generating .env file..."
          
          # Check if we have a custom .env for this environment
          if [ -f ".env.${{ github.event.inputs.environment || 'production' }}" ]; then
            cp ".env.${{ github.event.inputs.environment || 'production' }}" .env
            echo "Using environment-specific .env file"
          else
            cp .env.template .env
            echo "Using .env.template"
          fi
          
          # Add deployment metadata
          echo "" >> .env
          echo "# Auto-generated deployment metadata" >> .env
          echo "DEPLOYMENT_ID=${{ needs.pre-deployment.outputs.deploy-id }}" >> .env
          echo "DEPLOYED_BY=${{ github.actor }}" >> .env
          echo "DEPLOYMENT_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> .env
          echo "GIT_COMMIT=${{ github.sha }}" >> .env
          echo "GIT_BRANCH=${{ github.ref_name }}" >> .env
          echo "DEPLOYMENT_ENV=${{ github.event.inputs.environment || 'production' }}" >> .env

      - name: Create Secrets Files
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          MINIO_SECRET_KEY: ${{ secrets.MINIO_SECRET_KEY }}
          N8N_ENCRYPTION_KEY: ${{ secrets.N8N_ENCRYPTION_KEY }}
          GRAFANA_PASSWORD: ${{ secrets.GRAFANA_PASSWORD }}
        run: |
          echo "üîê Creating secret files..."
          
          # Create secrets from GitHub Secrets
          [ -n "$POSTGRES_PASSWORD" ] && echo "$POSTGRES_PASSWORD" > secrets/postgres_password.txt || echo "$(openssl rand -base64 32)" > secrets/postgres_password.txt
          [ -n "$MINIO_SECRET_KEY" ] && echo "$MINIO_SECRET_KEY" > secrets/minio_secret_key.txt || echo "$(openssl rand -base64 32)" > secrets/minio_secret_key.txt
          [ -n "$N8N_ENCRYPTION_KEY" ] && echo "$N8N_ENCRYPTION_KEY" > secrets/n8n_encryption_key.txt || echo "$(openssl rand -base64 32)" > secrets/n8n_encryption_key.txt
          [ -n "$GRAFANA_PASSWORD" ] && echo "$GRAFANA_PASSWORD" > secrets/grafana_password.txt || echo "$(openssl rand -base64 32)" > secrets/grafana_password.txt
          
          # Set secure permissions
          chmod 600 secrets/*.txt
          echo "‚úÖ Secrets created with secure permissions"

      - name: Validate Docker Compose Configuration
        run: |
          echo "üê≥ Validating Docker configuration..."
          cd docker
          docker compose config > /dev/null || docker-compose config > /dev/null
          if [ $? -eq 0 ]; then
            echo "‚úÖ Docker Compose configuration is valid"
          else
            echo "‚ùå Docker Compose configuration is invalid"
            exit 1
          fi

  deploy-services:
    name: Deploy Services
    runs-on: self-hosted
    needs: [pre-deployment, setup-environment]
    if: |
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.action == 'deploy' || github.event.inputs.action == 'update')) ||
      (github.event_name == 'push' && needs.pre-deployment.outputs.should-deploy == 'true')
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Stop Existing Services (if update)
        if: github.event.inputs.action == 'update'
        run: |
          echo "üõë Stopping existing services for update..."
          cd docker
          docker compose down || docker-compose down || true

      - name: Pull Docker Images
        run: |
          echo "üì¶ Pulling latest Docker images..."
          cd docker
          docker compose pull || docker-compose pull
          
      - name: Start Infrastructure Services
        run: |
          echo "üöÄ Starting infrastructure services..."
          cd docker
          
          # Start services in dependency order
          services_order=(
            "postgres"
            "redis"
            "minio"
            "qdrant"
            "ollama"
          )
          
          for service in "${services_order[@]}"; do
            echo "Starting $service..."
            docker compose up -d $service || docker-compose up -d $service
            echo "Waiting for $service to be ready..."
            sleep 15
          done

      - name: Wait for Services Health
        run: |
          echo "‚è≥ Waiting for services to be healthy..."
          ./scripts/wait-for-healthy.sh
          
      - name: Initialize Services
        run: |
          echo "üîß Initializing services..."
          
          # Make scripts executable
          chmod +x scripts/*.sh
          
          # Initialize in specific order
          echo "1Ô∏è‚É£ Initializing Ollama models..."
          ./scripts/init-ollama-models.sh
          
          echo "2Ô∏è‚É£ Initializing MinIO buckets..."
          ./scripts/init-minio-buckets.sh
          
          echo "3Ô∏è‚É£ Initializing Qdrant collections..."
          ./scripts/init-qdrant-collections.sh

      - name: Start Application Services
        run: |
          echo "üöÄ Starting application services..."
          cd docker
          docker compose up -d n8n grafana prometheus loki promtail || \
          docker-compose up -d n8n grafana prometheus loki promtail

      - name: Initialize N8N
        run: |
          echo "‚öôÔ∏è Initializing N8N..."
          # Wait extra time for N8N to fully start
          sleep 45
          ./scripts/init-n8n-setup.sh

      - name: Deploy Workflows
        run: |
          echo "üìã Deploying N8N workflows..."
          ./scripts/sync-n8n-workflows.sh

      - name: Run Smoke Tests
        continue-on-error: true
        run: |
          echo "üß™ Running smoke tests..."
          
          # Get the host IP
          HOST_IP=$(hostname -I | awk '{print $1}' || echo "localhost")
          
          # Test each service endpoint
          services=(
            "N8N|http://${HOST_IP}:5678/healthz"
            "Ollama|http://${HOST_IP}:11434/api/tags"
            "Qdrant|http://${HOST_IP}:6333/health"
            "MinIO|http://${HOST_IP}:9000/minio/health/ready"
            "Grafana|http://${HOST_IP}:3000/api/health"
            "Prometheus|http://${HOST_IP}:9090/-/healthy"
          )
          
          echo "Testing services on ${HOST_IP}..."
          failed=0
          
          for service_info in "${services[@]}"; do
            IFS='|' read -r service url <<< "$service_info"
            if curl -sf --max-time 10 "$url" > /dev/null; then
              echo "‚úÖ $service is healthy"
            else
              echo "‚ùå $service health check failed"
              ((failed++))
            fi
          done
          
          if [ $failed -gt 0 ]; then
            echo "‚ö†Ô∏è $failed services failed health checks"
            echo "This might be normal if services need more time to start"
          fi

  restart-services:
    name: Restart Services
    runs-on: self-hosted
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'restart'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Restart All Services
        run: |
          echo "üîÑ Restarting all services..."
          cd docker
          docker compose restart || docker-compose restart
          
      - name: Wait for Services
        run: |
          sleep 30
          ./scripts/wait-for-healthy.sh

  backup-services:
    name: Backup Services
    runs-on: self-hosted
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'backup'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Create Backup Script
        run: |
          cat > scripts/backup-all.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          
          BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
          mkdir -p "$BACKUP_DIR"
          
          echo "üì¶ Starting backup to $BACKUP_DIR..."
          
          # Backup PostgreSQL
          echo "Backing up PostgreSQL..."
          docker exec datalive-postgres pg_dumpall -U ${POSTGRES_USER:-datalive_user} > "$BACKUP_DIR/postgres-all.sql"
          
          # Backup N8N workflows
          echo "Backing up N8N workflows..."
          cp -r workflows "$BACKUP_DIR/"
          
          # Backup configurations
          echo "Backing up configurations..."
          cp -r config "$BACKUP_DIR/"
          cp .env "$BACKUP_DIR/.env.backup"
          
          # Create tar archive
          tar -czf "$BACKUP_DIR.tar.gz" "$BACKUP_DIR"
          rm -rf "$BACKUP_DIR"
          
          echo "‚úÖ Backup completed: $BACKUP_DIR.tar.gz"
          EOF
          
          chmod +x scripts/backup-all.sh
          
      - name: Run Backup
        run: |
          source .env
          ./scripts/backup-all.sh
          
      - name: Upload Backup
        uses: actions/upload-artifact@v3
        with:
          name: backup-${{ github.run_id }}
          path: backups/*.tar.gz
          retention-days: 30

  destroy-services:
    name: Destroy Services
    runs-on: self-hosted
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    environment: production
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Confirm Destruction
        run: |
          echo "‚ö†Ô∏è WARNING: This will destroy all DataLive services and data!"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Requested by: ${{ github.actor }}"
          echo "Waiting 10 seconds before proceeding..."
          sleep 10
          
      - name: Backup Before Destroy
        continue-on-error: true
        run: |
          echo "üíæ Creating final backup before destruction..."
          mkdir -p backups
          docker exec datalive-postgres pg_dumpall -U ${POSTGRES_USER:-datalive_user} > backups/final-backup-postgres.sql || true
          docker run --rm -v datalive_n8n_data:/data -v $(pwd)/backups:/backup alpine tar czf /backup/final-backup-n8n.tar.gz /data || true
          
      - name: Destroy Services
        run: |
          echo "üî• Destroying all services..."
          cd docker
          docker compose down -v || docker-compose down -v
          
      - name: Cleanup
        run: |
          echo "üßπ Cleaning up..."
          # Remove all project volumes
          docker volume ls | grep datalive | awk '{print $2}' | xargs -r docker volume rm || true
          
          # Clean build cache
          docker system prune -f || true
          
          echo "‚úÖ All services destroyed"

  post-deployment:
    name: Post Deployment
    runs-on: self-hosted
    needs: [pre-deployment, deploy-services]
    if: always() && needs.deploy-services.result != 'skipped'
    steps:
      - name: Generate Deployment Report
        run: |
          HOST_IP=$(hostname -I | awk '{print $1}' || echo "localhost")
          
          cat > deployment-report.md << EOF
          # DataLive Deployment Report
          
          **Deployment ID:** ${{ needs.pre-deployment.outputs.deploy-id }}
          **Environment:** ${{ github.event.inputs.environment || 'production' }}
          **Action:** ${{ github.event.inputs.action || 'auto-deploy' }}
          **Status:** ${{ needs.deploy-services.result }}
          **Deployed by:** ${{ github.actor }}
          **Date:** $(date)
          **Git Commit:** ${{ github.sha }}
          **Git Branch:** ${{ github.ref_name }}
          
          ## Service URLs
          - N8N: http://${HOST_IP}:5678
          - MinIO Console: http://${HOST_IP}:9001
          - Grafana: http://${HOST_IP}:3000
          - Qdrant Dashboard: http://${HOST_IP}:6333/dashboard
          
          ## Next Steps
          1. Access N8N at http://${HOST_IP}:5678
          2. Login with credentials from .env
          3. Verify all workflows are active
          4. Configure Google Drive OAuth if needed
          5. Test the RAG query endpoint
          
          ## Troubleshooting
          - Logs: \`docker logs datalive-[service]\`
          - Status: \`docker ps\`
          - Restart: \`docker restart datalive-[service]\`
          EOF
          
      - name: Upload Deployment Report
        uses: actions/upload-artifact@v3
        with:
          name: deployment-report-${{ needs.pre-deployment.outputs.deploy-id }}
          path: deployment-report.md

      - name: Notify Deployment Status
        if: always() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ needs.deploy-services.result }}"
          EMOJI="‚úÖ"
          COLOR="good"
          
          if [ "$STATUS" != "success" ]; then
            EMOJI="‚ùå"
            COLOR="danger"
          fi
          
          curl -X POST $SLACK_WEBHOOK_URL \
            -H 'Content-type: application/json' \
            -d "{
              \"attachments\": [{
                \"color\": \"${COLOR}\",
                \"title\": \"${EMOJI} DataLive Deployment ${STATUS}\",
                \"fields\": [
                  {
                    \"title\": \"Environment\",
                    \"value\": \"${{ github.event.inputs.environment || 'production' }}\",
                    \"short\": true
                  },
                  {
                    \"title\": \"Deployed by\",
                    \"value\": \"${{ github.actor }}\",
                    \"short\": true
                  },
                  {
                    \"title\": \"Deployment ID\",
                    \"value\": \"${{ needs.pre-deployment.outputs.deploy-id }}\",
                    \"short\": false
                  }
                ],
                \"footer\": \"GitHub Actions\",
                \"ts\": $(date +%s)
              }]
            }"

      - name: Create Issue on Failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Deployment Failed: ${context.workflow} #${context.runNumber}`,
              body: `## Deployment Failure Report
              
              **Workflow:** ${context.workflow}
              **Run Number:** ${context.runNumber}
              **Actor:** ${context.actor}
              **Environment:** ${{ github.event.inputs.environment || 'production' }}
              
              [View Failed Run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              
              Please investigate and fix the issue.`,
              labels: ['bug', 'deployment']
            })